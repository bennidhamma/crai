use crate::config::FilterConfig;
use crate::diff::chunk::{DiffChunk, FileDiff, Language, LineKind};
use crate::error::CraiResult;
use regex::Regex;
use std::collections::HashMap;

pub struct ChunkFilter {
    config: FilterConfig,
    generated_patterns: Vec<Regex>,
    import_patterns: HashMap<String, Vec<Regex>>,
}

impl ChunkFilter {
    pub fn new(config: FilterConfig) -> CraiResult<Self> {
        let generated_patterns = config
            .generated_file_patterns
            .iter()
            .map(|p| Regex::new(p))
            .collect::<Result<Vec<_>, _>>()?;

        let mut import_patterns = HashMap::new();
        for (lang, patterns) in &config.import_patterns {
            let compiled: Vec<Regex> = patterns
                .iter()
                .filter_map(|p| Regex::new(p).ok())
                .collect();
            import_patterns.insert(lang.clone(), compiled);
        }

        Ok(Self {
            config,
            generated_patterns,
            import_patterns,
        })
    }

    pub fn filter_chunk(&self, chunk: &DiffChunk, file: &FileDiff) -> FilterResult {
        // Check auto-generated files first
        if self.config.auto_filter_generated && self.is_generated_file(file) {
            return FilterResult {
                is_filtered: true,
                reason: Some(FilterReason::AutoGenerated),
                can_override: true,
            };
        }

        // Check for whitespace-only changes
        if self.config.auto_filter_whitespace && self.is_whitespace_only(chunk) {
            return FilterResult {
                is_filtered: true,
                reason: Some(FilterReason::WhitespaceOnly),
                can_override: true,
            };
        }

        // Check for import-only changes
        if self.config.auto_filter_imports && self.is_import_only(chunk, file.language) {
            return FilterResult {
                is_filtered: true,
                reason: Some(FilterReason::ImportOnly),
                can_override: true,
            };
        }

        // Check for renames
        if self.config.auto_filter_renames && self.is_rename_only(chunk, file) {
            return FilterResult {
                is_filtered: true,
                reason: Some(FilterReason::Rename),
                can_override: true,
            };
        }

        FilterResult {
            is_filtered: false,
            reason: None,
            can_override: false,
        }
    }

    pub fn filter_by_score(&self, score: f64) -> FilterResult {
        if score < self.config.controversiality_threshold {
            FilterResult {
                is_filtered: true,
                reason: Some(FilterReason::BelowThreshold),
                can_override: true,
            }
        } else {
            FilterResult {
                is_filtered: false,
                reason: None,
                can_override: false,
            }
        }
    }

    pub fn threshold(&self) -> f64 {
        self.config.controversiality_threshold
    }

    fn is_generated_file(&self, file: &FileDiff) -> bool {
        let path_str = file.path.to_string_lossy();
        self.generated_patterns
            .iter()
            .any(|p| p.is_match(&path_str))
    }

    fn is_whitespace_only(&self, chunk: &DiffChunk) -> bool {
        // Collect removed and added lines
        let removed: Vec<&str> = chunk
            .lines
            .iter()
            .filter(|l| l.kind == LineKind::Remove)
            .map(|l| l.content.as_str())
            .collect();

        let added: Vec<&str> = chunk
            .lines
            .iter()
            .filter(|l| l.kind == LineKind::Add)
            .map(|l| l.content.as_str())
            .collect();

        if removed.len() != added.len() {
            return false;
        }

        // Check if all pairs are whitespace-equivalent
        removed
            .iter()
            .zip(added.iter())
            .all(|(r, a)| normalize_whitespace(r) == normalize_whitespace(a))
    }

    fn is_import_only(&self, chunk: &DiffChunk, language: Option<Language>) -> bool {
        let lang_name = language.map(|l| l.name().to_string()).unwrap_or_default();
        let patterns = match self.import_patterns.get(&lang_name) {
            Some(p) => p,
            None => return false,
        };

        if patterns.is_empty() {
            return false;
        }

        // All non-context lines must be import statements
        chunk
            .lines
            .iter()
            .filter(|l| l.kind != LineKind::Context)
            .all(|line| {
                let content = &line.content;
                patterns.iter().any(|p| p.is_match(content))
            })
    }

    fn is_rename_only(&self, chunk: &DiffChunk, file: &FileDiff) -> bool {
        matches!(
            file.status,
            crate::diff::chunk::FileStatus::Renamed { .. }
        ) && chunk.lines.iter().all(|l| l.kind == LineKind::Context)
    }
}

#[derive(Debug, Clone)]
pub struct FilterResult {
    pub is_filtered: bool,
    pub reason: Option<FilterReason>,
    pub can_override: bool,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum FilterReason {
    WhitespaceOnly,
    ImportOnly,
    Rename,
    AutoGenerated,
    BelowThreshold,
}

impl FilterReason {
    pub fn description(&self) -> &'static str {
        match self {
            Self::WhitespaceOnly => "Whitespace-only change",
            Self::ImportOnly => "Import statement change",
            Self::Rename => "File rename without content change",
            Self::AutoGenerated => "Auto-generated file",
            Self::BelowThreshold => "Below controversiality threshold",
        }
    }
}

#[derive(Debug, Clone, Default)]
pub struct FilterStats {
    pub total_chunks: u32,
    pub filtered_chunks: u32,
    pub total_lines: u32,
    pub filtered_lines: u32,
    pub whitespace_lines: u32,
    pub import_lines: u32,
    pub rename_lines: u32,
    pub generated_lines: u32,
    pub below_threshold_lines: u32,
}

impl FilterStats {
    pub fn add_filtered(&mut self, reason: FilterReason, line_count: u32) {
        self.filtered_chunks += 1;
        self.filtered_lines += line_count;

        match reason {
            FilterReason::WhitespaceOnly => self.whitespace_lines += line_count,
            FilterReason::ImportOnly => self.import_lines += line_count,
            FilterReason::Rename => self.rename_lines += line_count,
            FilterReason::AutoGenerated => self.generated_lines += line_count,
            FilterReason::BelowThreshold => self.below_threshold_lines += line_count,
        }
    }

    pub fn add_unfiltered(&mut self, line_count: u32) {
        self.total_lines += line_count;
    }

    pub fn filter_percentage(&self) -> f64 {
        if self.total_lines == 0 {
            0.0
        } else {
            (self.filtered_lines as f64 / self.total_lines as f64) * 100.0
        }
    }
}

fn normalize_whitespace(s: &str) -> String {
    s.split_whitespace().collect::<Vec<_>>().join(" ")
}
